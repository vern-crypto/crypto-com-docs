"use strict";(self.webpackChunkcrypto_com_docs=self.webpackChunkcrypto_com_docs||[]).push([[1994],{3905:(e,n,t)=>{t.d(n,{Zo:()=>p,kt:()=>h});var o=t(7294);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);n&&(o=o.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,o)}return t}function s(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function r(e,n){if(null==e)return{};var t,o,a=function(e,n){if(null==e)return{};var t,o,a={},i=Object.keys(e);for(o=0;o<i.length;o++)t=i[o],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(o=0;o<i.length;o++)t=i[o],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var l=o.createContext({}),c=function(e){var n=o.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):s(s({},n),e)),t},p=function(e){var n=c(e.components);return o.createElement(l.Provider,{value:n},e.children)},d="mdxType",u={inlineCode:"code",wrapper:function(e){var n=e.children;return o.createElement(o.Fragment,{},n)}},g=o.forwardRef((function(e,n){var t=e.components,a=e.mdxType,i=e.originalType,l=e.parentName,p=r(e,["components","mdxType","originalType","parentName"]),d=c(t),g=a,h=d["".concat(l,".").concat(g)]||d[g]||u[g]||i;return t?o.createElement(h,s(s({ref:n},p),{},{components:t})):o.createElement(h,s({ref:n},p))}));function h(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var i=t.length,s=new Array(i);s[0]=g;var r={};for(var l in n)hasOwnProperty.call(n,l)&&(r[l]=n[l]);r.originalType=e,r[d]="string"==typeof e?e:a,s[1]=r;for(var c=2;c<i;c++)s[c]=t[c];return o.createElement.apply(null,s)}return o.createElement.apply(null,t)}g.displayName="MDXCreateElement"},3216:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>d,frontMatter:()=>i,metadata:()=>r,toc:()=>c});var o=t(7462),a=(t(7294),t(3905));const i={title:"Chrome Extension Wallet Integration (Aptos)",sidebar_position:30},s="Introduction",r={unversionedId:"defi-wallet/aptos-integration",id:"defi-wallet/aptos-integration",title:"Chrome Extension Wallet Integration (Aptos)",description:"Crypto.com | Wallet Extension now support the Aptos blockchain. Crypto.com | Wallet Extension is a free web application. Using Crypto.com | Wallet Extension, a user can store and transfer assets, and interact with the decentralized applications (dApps), all on the Aptos blockchain.",source:"@site/docs/defi-wallet/aptos-integration.md",sourceDirName:"defi-wallet",slug:"/defi-wallet/aptos-integration",permalink:"/crypto-com-docs/docs/defi-wallet/aptos-integration",draft:!1,editUrl:"https://github.com/vern-crypto/crypto-com-docs/tree/main/docs/defi-wallet/aptos-integration.md",tags:[],version:"current",sidebarPosition:30,frontMatter:{title:"Chrome Extension Wallet Integration (Aptos)",sidebar_position:30},sidebar:"defiWalletSidebar",previous:{title:"Chrome Extension Wallet Integration",permalink:"/crypto-com-docs/docs/defi-wallet/integration"},next:{title:"Chrome Extension Wallet Integration",permalink:"/crypto-com-docs/docs/defi-wallet/mobile-integration"}},l={},c=[{value:"Installing Crypto.com | Wallet Extension",id:"installing-cryptocom--wallet-extension",level:2},{value:"Connecting to Crypto.com | Wallet Extension",id:"connecting-to-cryptocom--wallet-extension-1",level:2},{value:"Switch network",id:"switch-network",level:2},{value:"Disconnecting Crypto.com | Wallet Extension",id:"disconnecting-cryptocom--wallet-extension",level:2},{value:"Verifying a signature",id:"verifying-a-signature",level:2},{value:"<code>onNetworkChange()</code> and <code>network()</code>",id:"onnetworkchange-and-network",level:2},{value:"<code>onAccountChange()</code>",id:"onaccountchange",level:2},{value:"<code>onDisconnect()</code>",id:"ondisconnect",level:2},{value:"Code 4000",id:"code-4000",level:2},{value:"Code 4001",id:"code-4001",level:2},{value:"Code 4100",id:"code-4100",level:2}],p={toc:c};function d(e){let{components:n,...t}=e;return(0,a.kt)("wrapper",(0,o.Z)({},p,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"introduction"},"Introduction"),(0,a.kt)("p",null,"Crypto.com | Wallet Extension now support the ",(0,a.kt)("a",{parentName:"p",href:"https://aptos.dev/"},"Aptos blockchain"),". Crypto.com | Wallet Extension is a free web application. Using Crypto.com | Wallet Extension, a user can store and transfer assets, and interact with the decentralized applications (dApps), all on the Aptos blockchain."),(0,a.kt)("p",null,"This developer documentation describes how to integrate Wallet into your dApp and enable your user to connect their Wallet to the Aptos blockchain."),(0,a.kt)("p",null,"NOTE: Crypto.com | Wallet Extension is currently available as a browser extension on ",(0,a.kt)("a",{parentName:"p",href:"https://chrome.google.com/webstore/detail/cryptocom-wallet-extensio/hifafgmccdpekplomjjkcfgodnhcellj"},"Google Chrome"),"."),(0,a.kt)("p",null,"The rest of the documentation describes in detail the following steps for your dApp integration:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Checking for Crypto.com | Wallet Extension."),(0,a.kt)("li",{parentName:"ul"},"Connecting to Crypto.com | Wallet Extension."),(0,a.kt)("li",{parentName:"ul"},"Getting a user to sign, and optionally, send, a transaction to the Aptos blockchain."),(0,a.kt)("li",{parentName:"ul"},"Getting a user to sign a message."),(0,a.kt)("li",{parentName:"ul"},"Handling event updates from the wallet."),(0,a.kt)("li",{parentName:"ul"},"Error messages.")),(0,a.kt)("hr",null),(0,a.kt)("h1",{id:"interface-of-windowdeficonnectaptos"},"Interface of ",(0,a.kt)("inlineCode",{parentName:"h1"},"window.deficonnect.aptos")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"import type { Types } from 'aptos'\n\nenum Network {\n  Testnet = 'Testnet',\n  Mainnet = 'Mainnet',\n  Devnet = 'Devnet',\n  'Aptos Testnet' = 'Testnet',\n  Aptos = 'Mainnet',\n  'Aptos Devnet' = 'Devnet',\n}\n\ntype Networks = keyof typeof Network\n\ninterface NetworkConfig {\n  name: string\n  chainType: 'aptos'\n  chainId: string\n  rpcUrl: string\n  symbol: string\n  explorer?: string\n}\n\ninterface IAccount {\n  publicKey: MaybeHexString | undefined\n  address: MaybeHexString | undefined\n  method?: string\n  status: number\n}\n\ninterface IOptions {\n  sender?: MaybeHexString\n  sequence_number?: any\n  max_gas_amount?: string,\n  gas_unit_price?: string,\n  gas_currency_code?: string,\n  expiration_timestamp_secs?: string,\n}\n\ninterface SignMessagePayload {\n  address?: boolean // Should we include the address of the account in the message\n  application?: boolean // Should we include the domain of the dapp\n  chainId?: boolean // Should we include the current chain id the wallet is connected to\n  message: string // The message to be signed and displayed to the user\n  nonce: string // A nonce the dapp should generate\n}\n\ninterface SignMessageResponse {\n  address: string\n  application: string\n  chainId: number\n  fullMessage: string // The message that was generated to sign\n  message: string // The message passed in by the user\n  nonce: string\n  prefix: string // Should always be APTOS\n  signature: string // The signed full message\n}\n\ninterface IDeficonnectAptos {\n  connect: (network?: NetworkConfig) => Promise<IAccount>;\n  account: () => Promise<IAccount>;\n  isConnected: () => Promise<boolean>;\n  signAndSubmitTransaction(\n    transaction: Types.TransactionPayload,\n    options?: IOptions\n  ): Promise<Types.Transaction>;\n  signTransaction(transaction: Types.TransactionPayload, options?: IOptions): Promise<Uint8Array>;\n  signMessage(message: SignMessagePayload): Promise<SignMessageResponse>;\n  disconnect(): Promise<void>;\n  network(): Promise<Networks>;\n  onAccountChange: (listener: (newAddress: IAccount) => void) => void;\n  onNetworkChange: (listener: (network: { networkName: Networks }) => void) => void;\n}\n")),(0,a.kt)("hr",null),(0,a.kt)("h1",{id:"connecting-to-cryptocom--wallet-extension"},"Connecting to Crypto.com | Wallet Extension"),(0,a.kt)("p",null,"To use Crypto.com | Wallet Extension with your dApp, your user must first install Crypto.com | Wallet Extension on their Chrome browser. Crypto.com | Wallet Extension injects an ",(0,a.kt)("inlineCode",{parentName:"p"},"aptos")," object inside the ",(0,a.kt)("inlineCode",{parentName:"p"},"deficonnect")," object of ",(0,a.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/API/Window"},"window")," on any web app the user visits."),(0,a.kt)("p",null,"To check if the user has installed Crypto.com | Wallet Extension, perform the below check:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-javascript"},"const isInstalled = window.deficonnect.aptos\n")),(0,a.kt)("p",null,"If Crypto.com | Wallet Extension is not installed, you can prompt the user to first install Crypto.com | Wallet Extension and provide the below installation instructions. For example, see below:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-javascript"},"const getWallet = () => {\n    if (window.deficonnect && window.deficonnect.aptos) {\n        return window.deficonnect.aptos;\n    } else {\n        window.open('https://crypto.com/defi-wallet#wallet_extension', `_blank`);\n    }\n}\n")),(0,a.kt)("h2",{id:"installing-cryptocom--wallet-extension"},"Installing Crypto.com | Wallet Extension"),(0,a.kt)("p",null,"To install Crypto.com | Wallet Extension on your Chrome browser, you can download it from the ",(0,a.kt)("a",{parentName:"p",href:"https://chrome.google.com/webstore/detail/cryptocom-wallet-extensio/hifafgmccdpekplomjjkcfgodnhcellj"},"chrome store"),"."),(0,a.kt)("h2",{id:"connecting-to-cryptocom--wallet-extension-1"},"Connecting to Crypto.com | Wallet Extension"),(0,a.kt)("p",null,"After confirming that the web app has the ",(0,a.kt)("inlineCode",{parentName:"p"},"deficonnect.aptos")," object, we can connect to Wallet by calling ",(0,a.kt)("inlineCode",{parentName:"p"},"deficonnect.aptos.connect()"),"."),(0,a.kt)("p",null,"When you call ",(0,a.kt)("inlineCode",{parentName:"p"},"deficonnect.aptos.connect()"),", it prompts the user to allow your web app to make additional calls to the Wallet, and obtains from the user basic information like the address and public key. It also exposes a convenience isConnected."),(0,a.kt)("p",null,"See the example code below:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-javascript"},"await window.deficonnect.aptos.connect(); // { address: string, publicKey: string }\n\nawait window.deficonnect.aptos.isConnected(); // true\n")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"NOTE"),": After a web application connects to the wallet for the first time, it becomes whitelisted session. Once whitelisted, it's possible for the application to automatically connect to the wallet on subsequent visits or page refreshes."),(0,a.kt)("h2",{id:"switch-network"},"Switch network"),(0,a.kt)("p",null,"Crypto.com | Wallet Extension also support switch network, you can pass ",(0,a.kt)("inlineCode",{parentName:"p"},"networkConfig")," parameter into ",(0,a.kt)("inlineCode",{parentName:"p"},"connect()"),", and it will trigger network switch confirmation popup."),(0,a.kt)("p",null,"See the example code below:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"interface AptosNetworkConfig {\n  name: string\n  chainType: 'aptos'\n  chainId: string\n  rpcUrl: string\n  symbol: string\n  explorer?: string\n}\n\nconst networkConfig: AptosNetworkConfig = {\n  chainId: '2',\n  chainType: 'aptos',\n  name: 'Testnet',\n  rpcUrl: 'https://fullnode.testnet.aptoslabs.com/v1',\n  symbol: 'APT',\n}\n\nawait window.deficonnect.aptos.connect(networkConfig); // { address: string, publicKey: string }\n\n")),(0,a.kt)("h2",{id:"disconnecting-cryptocom--wallet-extension"},"Disconnecting Crypto.com | Wallet Extension"),(0,a.kt)("p",null,"When you want the web app to forget about the connection status with the Wallet, you can do this by calling ",(0,a.kt)("inlineCode",{parentName:"p"},"window.deficonnect.aptos.disconnect()")," in your web app. See below:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-javascript"},"await window.deficonnect.aptos.disconnect()\n")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"NOTE"),": After disconnecting, the web app must reconnect to the Wallet if user want to make requests again."),(0,a.kt)("hr",null),(0,a.kt)("h1",{id:"sending-a-transaction"},"Sending a Transaction"),(0,a.kt)("p",null,"After the web app is connected to the Wallet, the web app can prompt the user to sign and send transactions to the Aptos blockchain."),(0,a.kt)("p",null,"Crypto.com | Wallet Extension API handles the transactions in the following two ways:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"Sign a transaction and submit it to the Aptos blockchain. Return a pending transaction to the web app."),(0,a.kt)("li",{parentName:"ol"},"Sign a transaction but do not submit the transaction to the Aptos blockchain. Return the signed transaction to the web app, for the web app to submit the transaction.")),(0,a.kt)("p",null,"See the below examples for both the options."),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},"For more on Aptos transactions, see the\n",(0,a.kt)("a",{parentName:"p",href:"https://aptos-labs.github.io/ts-sdk-doc/"},"Aptos Typescript SDK"),"\nand\n",(0,a.kt)("a",{parentName:"p",href:"https://aptos.dev/guides/creating-a-signed-transaction"},"Transactions guide from Aptos"),"\n."),(0,a.kt)("h2",{parentName:"blockquote",id:"sign-and-submit"},"Sign and submit"),(0,a.kt)("p",{parentName:"blockquote"},"The below code example shows how to use the ",(0,a.kt)("inlineCode",{parentName:"p"},"signAndSubmitTransaction()")," API to sign the transaction and send it to the Aptos blockchain."),(0,a.kt)("pre",{parentName:"blockquote"},(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"interface IResponse {\n  hash: string\n  sender?: string\n  sequence_number?: string\n  max_gas_amount?: string\n  gas_unit_price?: string\n  expiration_timestamp_secs?: string\n  payload?: TransactionPayload\n  signature?: AccountSignature\n}\n"))),(0,a.kt)("p",null,'const wallet = window.deficonnect.aptos.connect(); // see "Connecting"'),(0,a.kt)("p",null,"// Example Transaction, following an ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/aptos-labs/aptos-core/blob/main/ecosystem/typescript/sdk/src/generated/models/EntryFunctionPayload.ts#L8-L21"},"EntryFunctionPayload"),"\nconst transaction = {\narguments: ","[wallet.address, '717']",",\nfunction: '0x1:\ud83e\ude99:transfer',\ntype: 'entry_function_payload',\ntype_arguments: ","['0x1::aptos_coin::TestCoin']",",\n};"),(0,a.kt)("p",null,"try {\nconst pendingTransaction: IResponse = await window.deficonnect.aptos.signAndSubmitTransaction(transaction);"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"// In most cases a dApp will want to wait for the transaction, in these cases you can use the typescript sdk\nconst client = new AptosClient('https://testnet.aptoslabs.com');\nclient.waitForTransaction(pendingTransaction.hash);\n")),(0,a.kt)("p",null,'} catch (error) {\n// see "Errors"\n}'),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"## Sign only\nThe below code example shows how to use the `signTransaction()` API to only sign the transaction, without submitting it to the Aptos blockchain.\n```javascript\nconst wallet = window.deficonnect.aptos.connect(); // see \"Connecting\"\n\n// Example Transaction\nconst transaction = {\n    arguments: [wallet.address, '717'],\n    function: '0x1::coin::transfer',\n    type: 'entry_function_payload',\n    type_arguments: ['0x1::aptos_coin::TestCoin'],\n};\n\ntry {\n    const signTransaction = await window.deficonnect.aptos.signTransaction(transaction)\n} catch (error) {\n    // see \"Errors\"\n}\n")),(0,a.kt)("hr",null),(0,a.kt)("h1",{id:"signing-messages"},"Signing Messages"),(0,a.kt)("p",null,"A web app can also request the user to sign a message, by using API ",(0,a.kt)("inlineCode",{parentName:"p"},"window.deficonnect.aptos.signMessage(payload: SignMessagePayload)"),"."),(0,a.kt)("p",null,"Web apps can write their own message, then send it to the Wallet. The user will be prompted to sign that message, and then the signed message will be returned to the web app.\nThe following is provided for additional security."),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"signMessage(payload: SignMessagePayload)")," prompts the user with the ",(0,a.kt)("inlineCode",{parentName:"li"},"payload.message")," to be signed",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"returns ",(0,a.kt)("inlineCode",{parentName:"li"},"Promise<SignMessageResponse>"))))),(0,a.kt)("p",null,"Types:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"export interface SignMessagePayload {\n  address?: boolean; // Should we include the address of the account in the message\n  application?: boolean; // Should we include the domain of the dapp\n  chainId?: boolean; // Should we include the current chain id the wallet is connected to\n  message: string; // The message to be signed and displayed to the user\n  nonce: string; // A nonce the dapp should generate\n}\n\nexport interface SignMessageResponse {\n  address: string;\n  application: string;\n  chainId: number;\n  fullMessage: string; // The message that was generated to sign\n  message: string; // The message passed in by the user\n  nonce: string,\n  prefix: string, // Should always be APTOS\n  signature: string; // The signed full message\n}\n")),(0,a.kt)("h2",{id:"verifying-a-signature"},"Verifying a signature"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"import nacl from 'tweetnacl';\n\nconst message = \"hello\";\nconst nonce = \"random_string\"\n\ntry {\n  const response = await window.deficonnect.aptos.signMessage({\n    message,\n    nonce,\n  });\n  const { publicKey } = await window.deficonnect.aptos.account();\n  // Remove the 0x prefix\n  const key = publicKey!.slice(2, 66);\n  const verified = nacl.sign.detached.verify(Buffer.from(response.fullMessage), \n                                             Buffer.from(response.signature, 'hex'), \n                                             Buffer.from(key, 'hex'));\n  console.log(verified);\n} catch (error) {\n  console.error(error);\n}\n")),(0,a.kt)("hr",null),(0,a.kt)("h1",{id:"event-listening"},"Event Listening"),(0,a.kt)("h2",{id:"onnetworkchange-and-network"},(0,a.kt)("inlineCode",{parentName:"h2"},"onNetworkChange()")," and ",(0,a.kt)("inlineCode",{parentName:"h2"},"network()")),(0,a.kt)("p",null,"A dApp may want to make sure that a user is on the right network. In this case you will need to check what network the wallet is using."),(0,a.kt)("p",null,"Default networks provided by the wallet:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-javascript"},"// default networks in the wallet\nenum Network {\n  Testnet = 'Testnet',\n  Mainnet = 'Mainnet',\n  Devnet = 'Devnet'\n}\n\n// Current network\nlet network = await window.deficonnect.aptos.network();\n\n// event listener for network changing\nwindow.deficonnect.aptos.onNetworkChange((newNetwork) => {\n  network = newNetwork.networkName;\n});\n")),(0,a.kt)("h2",{id:"onaccountchange"},(0,a.kt)("inlineCode",{parentName:"h2"},"onAccountChange()")),(0,a.kt)("p",null,"In the Wallet a user may change accounts while interacting with your app. To check for these events you can listen for them with ",(0,a.kt)("inlineCode",{parentName:"p"},"onAccountChange")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-javascript"},"// get current account\nlet currentAccount = await window.aptos.account();\n\n// event listener for disconnecting\nwindow.deficonnect.aptos.onAccountChange((newAccount) => {\n  // If the new account has already connected to your app then the newAccount will be returned\n  if (newAccount) {\n    currentAccount = newAccount;\n  } else {\n    // Otherwise you will need to ask to connect to the new account\n    currentAccount = window.deficonnect.aptos.connect();\n  }\n});\n")),(0,a.kt)("h2",{id:"ondisconnect"},(0,a.kt)("inlineCode",{parentName:"h2"},"onDisconnect()")),(0,a.kt)("p",null,"A user may choose to disconnect from your dApp. In that case you will want to update your state."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"// get current connection status\nlet connectionStatus = await window.deficonnect.aptos.isConnected();\n\n// event listener for disconnecting\nwindow.deficonnect.aptos.onDisconnect(() => {\n  connectionStatus = false;\n});\n")),(0,a.kt)("h1",{id:"errors"},"Errors"),(0,a.kt)("p",null,"When making requests to Petra Wallet API, you may receive an error. The following is a partial list of the possible errors and their corresponding codes:"),(0,a.kt)("h2",{id:"code-4000"},"Code 4000"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Code: 4000"),(0,a.kt)("li",{parentName:"ul"},"Name: No Accounts"),(0,a.kt)("li",{parentName:"ul"},"Message: No accounts found.")),(0,a.kt)("h2",{id:"code-4001"},"Code 4001"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Code: 4001"),(0,a.kt)("li",{parentName:"ul"},"Name: User rejection"),(0,a.kt)("li",{parentName:"ul"},"Message: The user rejected the request.")),(0,a.kt)("h2",{id:"code-4100"},"Code 4100"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Code: 4100"),(0,a.kt)("li",{parentName:"ul"},"Name: Unauthorized"),(0,a.kt)("li",{parentName:"ul"},"Message: The requested method and/or account has not been authorized by the user.")))}d.isMDXComponent=!0}}]);